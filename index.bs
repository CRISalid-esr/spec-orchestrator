<pre class='metadata'>
Title: Orchestrator for a decentralized Web network
Shortname: orchestrator
Level: 1
Status: LD
URL: https://mellonscholarlycommunication.github.io/spec-orchestrator
Editor: Miel Vander Sande, meemoo - [Flemish Institute for Archiving](https://meemoo.be), miel.vandersande@meemoo.be
Editor: Patrick Hochstenbach, Ghent University, patrick.hochstenbach@ugent.be
Editor: Ruben Dedecker, Ghent University, ruben.dedecker@ugent.be
Abstract: This specification describes the implementation requirements for the Ochestrator component.
Markup Shorthands: markdown yes
</pre>

<style>
table {
  margin: 25px auto;
  border-collapse: collapse;
  border: 1px solid #eee;
  border-bottom: 2px solid #005A9C;
}
table tr:hover {
  background: #f4f4f4;
}
table tr:hover td {
  color: #555;
}
table th, table td {
  color: #999;
  border: 1px solid #eee;
  padding: 12px 12px;
  border-collapse: collapse;
}
table th {
  background: #005A9C;
  color: #fff;
}
table th.last {
  border-right: none;
}
</style>

Set of documents {#set}
=======================

This document is one of the specifications produced by the **ResearcherPod** and **ErfgoedPod** project:

1. [Overview](/spec-overview/)
2. [Orchestrator](/spec-orchestrator/) (this document)
3. [Data Pod](/spec-datapod/)
4. [Rule language](/spec-rulelanguage/)
5. [Artefact Lifecycle Event Log](/spec-eventlog/)
6. [Notifications](/spec-notifications/)
7. [Collector](/spec-collector/)

Introduction {#intro}
=====================

In a [Solid decentralized network](https://solidproject.org/), data, and services the services that use them, do not resort in one place, but are intentionally distributed.
As a result, actors in the network, such as institutions or service providers, need to potentionally involve and communicate with multiple services in order to execute a business process or workflow,
where each services executes a dedicated task (eg. registering or archiving a dataset).
Hence, to avoid excessive manual work, this document specifies the Orchestrator component, which is able to automate such task orchestration.

Network actors maintain their data in a [=Data Pod=],
which is by design a "passive" component: it offers secure data access via Linked Data Platform [[!LDP]] to others, but cannot perform actions such as invoking remote services on the network or reading and writing network content.
These capabilities are therefore delegated to the Orchestrator. On behalf of the actor, the Orchestrator responds to [=triggers=] by executing a number of [=actions=] dictated by a machine-readable [=policy=].
Possible triggers are incoming notifications, perceived changes in the data, or manual invocation by an actor.
Possible actions are sending notifications to other actors, requesting access to resources in a [=Data Pod=], reading data from a [=Data Pod=], or writing data to a [=Data Pod=].

The Orchestrator implements the autonomous agent model: an intelligent software instance that operates on an actor's behalf but without any interference of that actor.
In practice, an Orchestrator is dedicated to a single [=Data Pod=] for which is has access rights to all relevant resources, including the Linked Data Notification [[!LDN]] [=inbox=]
and the [=Artefact Lifecycle Event Log=].
Its autonomy is supplied by the [=Policy=], which dictates business rules in a declarative manner using a [=policy language=].

The remainder of this document specifies the requirements for implementing an [=Orchestrator=] component.

# Definitions

This document uses the following defined terms from [[spec-overview#definitions]]:

- <dfn export>Autonomous Agent</dfn>
- <dfn export>Policy Language</dfn>
- <dfn export>Actor</dfn>
- <dfn export>Artefact</dfn>
- <dfn export>Maintainer</dfn>
- <dfn export>Data Pod</dfn>
- <dfn export>Inbox</dfn>
- <dfn export>Artefact Lifecycle Event Log</dfn>
- <dfn export>Service Hub</dfn>
- <dfn export>Policy</dfn>
- <dfn export>Dashboard</dfn>

# Document Conventions

Within this document, the following namespace prefix bindings are used: 

<table>
  <thead>
    <tr>
      <th>Prefix
      <th>Namespace
  <tbody>
    <tr>
      <td>as
      <td>https://www.w3.org/ns/activitystreams#
    <tr>
      <td>schema
      <td>https://schema.org
    <tr>
      <td>ldp
      <td>http://www.w3.org/ns/ldp#
    <tr>
      <td>acl
      <td>http://www.w3.org/ns/auth/acl#
</table>

High-level overview {#high-level}
=====================

An <dfn export>Orchestrator</dfn> instance is an [=Autonomous Agent=] dedicated to a single [=Data Pod=], [=Service Hub=], or any other actor hosting the [=Artefact Lifecycle Event Log=] and a [=Inbox=] resources.
It interprets and executes business rules described in a [=policy=].
The Orchestrator watches the [=Inbox=] for possible triggers, while it records the actions it takes to the to the [=Artefact Lifecycle Event Log=].

## Perspectives

### Data Pod

From a [=Data Pod=] perspective,
the [=Orchestrator=] participates in the network on behalf of the [=Data Pod=]'s owner or [=Maintainer=].
At instantiation time,
a [=Maintainer=] connects the [=Orchestrator=] to the [=Inbox=] and [=Artefact Lifecycle Event Log=]
of its [=Data Pod=]. 

The [=Orchestrator=] executes [=Policy=] rules based on incoming [=Triggers=]. There are two main sources
of these tiggers: 1) incoming notifications that are send to the LDN [=Inbox=] of the [=Data Pod=] , 2) outgoing
notifications that are send by the [=Maintainer=] to the LDN [=Inbox=] of the [=Orchestrator=].

When a trigger arrives,
the [=Orchestrator=] consults the [=policy=] - a set of business rules fixed an maintained by the [=Maintainer=] using the [=Dashboard=],
which results in zero or more [=actions=] to take.
An [=Action=] can involve reading resources from or sending notifications to [=data pods=] (including the one it's connected to) or [=Service Hubs=].

The [=Orchestrator=] records every taken [=action=] in the [=data pod=]'s [=Artefact Lifecycle Event Log=].
When the [=Orchestrator=] requires input from the [=Maintainer=],
it can communicate this via the LDN [=Inbox=] of the Data Pod. The [=Dashboard=] presents this event 
to the [=Maintainer=] in an actionable way. These actions by the [=Maintainer=] could result 
in a new [=trigger=].

<pre class='include'>
path: images/high-level.svg
</pre>

### Service Hub

From a [=Service Hub=] perspective,
the [=Orchestrator=] establishes automated response to notifications from other network [=actors=] and [=orchestrators=] in context of the provided service.
As a possible side-effect, it can also actively consults additional [=actors=] in order to complete the service.
The [=Orchestrator=] responds by delivering a new notification in the [=Inbox=] of the actor that invoked the service.
It is the [=Policy=] that dictates what response to construct and what consecutive [=actions=] (reading resources from or sending notifications to [=data pods=] or other [=service hubs=]) need to be performed.

<pre class='include'>
path: images/high-level-servicehub.svg
</pre>


## Common interaction pattern

A common activity is the [=Maintainer=] of a [=Data Pod=] invoking a service provided by a [=Service Hub=].
Both [=actors=] can be considered operating an [=orchestrator=] to automate their participation in the network.
Hence, a common interaction pattern is as follows:

1. The [=maintainer=] at [=Data Pod=] `A` performs an action that affects or interests other actors in the network
 (eg. adding a new artefact in the data pod).
2. The [=maintainer=] uses the [=Dashboard=] to reflect this action by sending `event A` to the
 [=Inbox=] of `Orchestrator A`.
3. The new Inbox `event A` triggers `Orchestrator A` to take consecutive [=action=].
4. `Orchestrator A` consults its `Policy A` for the received [=trigger=], which dictates that it
   needs to inform the [=service hub=] `B` about the event.
5. `Orchestrator A` sends a notification to `Inbox B` of [=service hub=] `B`.
6. The notification in the [=Inbox=] of [=service hub=] `B` triggers `Orchestrator B` to take 
   consecutive [=action=].
7. `Orchestrator B` consults its `Policy B` for the received [=trigger=], which dictates that it 
   needs to process the artefact and inform the [=maintainer=] about the outcome.
8. `Orchestrator B` processes the contents of the notification using an internal process 
   (eg. index the new artefact in the repository).
9. When completed, `Orchestrator B` adds to `Event log B` that the contents of the notification 
   have been processed.
10. `Orchestrator B` sends a notification to `Inbox A` of the [=Data Pod=] `A`.
11. The notification in the [=Inbox=] of the [=Data Pod=] `A` triggers `Orchestrator A` to take
   consecutive [=action=].
12. `Orchestrator A` adds to `Event log A` that the original event has been processed by 
   the [=service hub=] `B`.
13. The [=Dashboard=] displays `Event log A` to the [=maintainer=] to show that the necessary 
   actions have been taken.

<img src="images/high-level-comm.svg" width="600">

Data Pod Initialization  {#init}
====================

To operate autonomously, an Orchestrator has to obtain access to some resources in the [=Data Pod=].
Solid Pod resources comform to the [Web Access Control](https://solidproject.org/TR/protocol#web-access-control)
specification. Orchestrators that are complian with the [[solid-protocol#solid-app]] 
Client-Side Implementation requirements can gain access to these resources and manage them on behalf
of the maintainer.

An Orchestrator instance requires a minimal setup on the Data Pod in order to function as intended.

This minimum setup on the [=Data Pod=] MUST have:

- An LDN [=Inbox=] with:
    - `acl:Read` access for the Orchestrator
    - `acl:Append` access for the Orchestrator and the Network (that can be the whole world)
- An [=Artefact Event Log=] with:
    - `acl:Read` access for the Orchestrator and the Network (that can be the whole world)
    - `acl:Append` access for the Orchestrator

The maintainer SHOULD have:

- A WebID profile entry for:
    - The location of the Data Pod LDN [=Inbox=]
    - The location of the [=Artefact Lifecycle Event Log=]
    - The WebId of the Orchestrator

The [=Data Pod=] MAY have:

- An LDP Container or Resource that needs to be watched with:
    - `acl:Read` access for the Orchestrator
- An LDP Container with one or more [=Policy=] rules

An Orchestrator MAY expose an initialization interface to assist the Data Pod [=Maintainer=] in 
setting up the required resources and ACL settings.

Issue: The section below is very unclear, should a Dashboard app be created that does this
initialiation, or should the remote Orchestrator get rights to do this initialization?

This provisioning MUST be possible using a `PUT` or `POST` to a dedicated [[!HTTP11]] resource if the orchestrator is deployed as a web service; see [[#deploy]].
This interface MAY also use an [[LDP#ldpr-resource]] or even [[LDP#ldpr-container]] in case the information is supplied using a description in [[!RDF11-primer]].

An Orchestrator is be deployable as a <dfn export>local background process</dfn> or as a <dfn export>remote web service</dfn>.
In case of the latter, an actor SHOULD be able to spawn, initialize and trigger the instance over [[!HTTP11]], as defined in [[#init]] and [[#triggers]].

The Orchestrator has an [=Inbox=] for communicating with the [=Data Pod=] maintainer using Linked Data Notifications [[LDN]] .
This Orchestrator [=Inbox=] can live in the same [=Data Pod=] as the [=Maintainer=] [=Inbox=] and 
[=Artefact Lifecycle Event Log=].

Example of spawning an orchestrator using Linked Data Notifications:

<div class="example">

<pre>
POST /orchestrator/inbox HTTP/1.1
Host: example.org
Content-Type: application/ld+json;profile="https://www.w3.org/ns/activitystreams"
Content-Language: en

{
  "@context": [
      "https://www.w3.org/ns/activitystreams",
      {
        "policy": "http://mellon.project.org/policy"
      }
  ],
  "summary": "Spawn orchestrator",
  "type": "Create",
  "actor": "http://maintainer.institution.org/profile/card#me",
  "object": {
    "type"    : "Service" ,
    "inbox"   : "http://my.institution.org/inbox" ,
    "outbox"  : "http://my.institution.org/events" ,
    "policy"  : [
          "http://maintainer.institution.org/policy/", 
          "http://my.institution.org/policy"
    ]
  }
}
</pre>

</div>

Policy {#policy-sec}
=====================

Note: PHOCHSTE: The Inbox and Artefact Lifecycle Event Log to read can also be provided by the webid

Note: PHOCHSTE: It is unclear from this section how the Orchestrator is maintained : started, stopped,
consulted for errors (what if a policy rule has syntax or runtime errros?).

Orchestrators solely execute business logic catured in [=policies=].
Thus, they MUST allow actors to supply one or more [[URI]]s pointing to a [=policy=].
These policies MUST be written in the [=policy language=].
An actor SHOULD supply at least one [=policy=] in order to allow the orchestrator to function.
The policy is a set of rules that determines the orchestrator's level of autonomy. 
A rule dictates what [=action=] to take when a [=trigger=] occurs ([[#triggers]]) on behalf of the maintainer.
In practice, the policy reflects a composition of procedures imposed by:

- the institution (ie. the employer of the maintainer and the owner of the artefacts);
- the domain (ie. the broader collaboration context the institution is situated in);
- legislation (ie. the legal obligations);
- or personal preference (ie. the maintainer).

- `acl:Read` to the [=inbox=] resource (discoverable with `http://www.w3.org/ns/ldp#inbox`)
- `acl:Read` and `acl:Append` to the [=Artefact Lifecycle Event Log=] resource.
- `acl:Read` to any watched [[LDP]] resource.
Hence, different policies need to have a common language to achieve interoperability. 
This rule language is described in [spec-rulelanguage].

A orchestrator MUST be able to interpret and executed policies that comply with [spec-rulelanguage].
Requirements regarding [=actions=] and [=triggers=] are discussed in the next sections.

Triggers {#triggers}
=====================

A <dfn>trigger</dfn> is an event to which an orchestrator can respond by taking [=actions=].
An orchestrator MUST respond to the following three types of triggers:

- a new incoming Linked Data Notification [[!LDN]] in the [=inbox=] of the [=Data Pod=]
    - This inbox should be appendable by the whole network
- a new incoming Linked Data Notification [[!LDN]] in the [=inbox=] of the Orchestrator 
    - This inbox can be private to the Maintainer and Orchestrator
- an observed state changes to watched [=data pod=] resources
- a scheduled trigger from the internal time-based event scheduler

A trigger MUST be identifyable by a [[!URI]], such that the rules written in the [[spec-rulelanguage]] can refer to its occurence.

An [=Orchestrator=] MUST be a compliant [[!LDN]] [Consumer](https://www.w3.org/TR/ldn/#consumer).
The [=Orchestrator=] MAY advertise multiple inboxes.
In this case, the [=Orchestrator=] MUST retrieve incoming Linked Data Notifications from all advertised inboxes.
Inbox security is discussed in the [security considerations](#security-considerations) sections.

An [=Orchestrator=] SHOULD be able to differentiate between Linked Data Notification sent by the
[=Maintainer=] of the [=Data pod=], a [=Service Hub=] and by the [=Orchestrator=] itself. This
should prevent sending the [=Orchestrator=] in a loop responding to its own triggers.

An [=Orchestrator=] SHOULD have some form data validation of incoming triggers and only respond to  
triggers that correspond to a RDF data shape. Technologies such as [SHACL](https://www.w3.org/TR/shacl/),
[SHeX](https://www.w3.org/TR/shacl/), [SPARQL](https://www.w3.org/TR/sparql11-query/) CONSTRUCT or
[Notation3](https://w3c.github.io/N3/spec/) can be used to validate triggers.

An [=Orchestrator=] MAY have some mechanism in place to validate the origin of the triggers. Technologies
such as [Linked Data Proofs](https://w3c-ccg.github.io/ld-proofs/) can by used to sign all 
Linked Data Notifications that are sent over the network, and are validated by the Orchestrator.

An [=Orchestrator=] SHOULD be able to process any notification descrived in the 
[List of Notifications](https://mellonscholarlycommunication.github.io/spec-notifications/).

An [=Orchestrator=] SHOULD be able to execute one or more [=Policy=] documents that are defined by 
the [=Maintainer=]. An example how [=Policy=] documents can be written is available in the
[Rule language for decentralized business processes](https://mellonscholarlycommunication.github.io/spec-rulelanguage/).

Example of a `Create` trigger using Linked Data Notifications:

<div class="example">

<pre>

POST /orchestrator/inbox HTTP/1.1
Host: alice.institution.org 
Content-Type: application/ld+json;profile="https://www.w3.org/ns/activitystreams"
Content-Language: en
{
    "@context": "https://www.w3.org/ns/activitystreams",
    "id": "urn:uuid:AD02A16E-2F5C-408E-8A4D-D596C6421969",
    "type": "Create",
    "summary": "Alice created an artefact",
    "actor": {
      "id": "https://alice.institution.org/profiles/card#me",
      "type": ["Person"],
      "inbox": "https://alice.institution.org/inbox",
      "name": "Alice"   
    },
    "origin": {
      "id": "https://acme.net/shinyapps/DashBoard123",
      "type": "Application",
      "name": "Dashboard of Alice" 
    },
    "object": "http://alice.institution.org/artefacts/1",
    "published": "2014-09-30T12:34:56Z"
}
</pre>

</div>

Example of a [=Policy=] to forward all `Create` events from `Alice` to `Bob` using 
a [=Policy=] rule:

<div class="example">

<pre>
<b>rule</b> "Forward to Bob"

as:   &lt;https://www.w3.org/ns/activitystreams#&gt;
pol:  &lt;https://www.example.org/ns/policy#&gt;
fno:  &lt;https://w3id.org/function/ontology#&gt;
ex:   &lt;https://www.example.org/&gt;
alice:        &lt;https://alice.institution.org/profiles/card#me&gt;
bob:          &lt;https://bob.institution.org/profiles/card#me&gt;
orchestrator: &lt;https://instutition.org/orchestrator/profile/card#me&gt;

<b>when</b>

 ?notification a as:Create  
 ?notification as:actor alice:

<b>then</b>

 ?notifiction as:target bob:

 [ pol:policy  [
      a fno:Execution ;
      fno:executes ex:sendTarget [
        ex:notification ?notification
      ]
   ]
 ]
</pre>

</div>

## Observing resource state changes  ## {#trigger-resource}

Note: PHOCHSTE: This needs some more work to explain how this could work.

An Orchestrator MAY accept resource stage changes of 
[Linked Data Platform Resources](https://www.w3.org/TR/ldp/#ldpr) as triggers for policy actions.
In this case, the Orchestrator MUST be granted READ-acess all observed 
[Linked Data Platform Resources](https://www.w3.org/TR/ldp/#ldpr).
In the case that an observed [Linked Data Platform Resources](https://www.w3.org/TR/ldp/#ldpr) 
is also a [Linked Data Platform Container](https://www.w3.org/TR/ldp/#ldpc), the Orchestrator SHOULD
observe state changes for all [Linked Data Platform Resources](https://www.w3.org/TR/ldp/#ldpr) 
that are contained by the observed [Linked Data Platform Container](https://www.w3.org/TR/ldp/#ldpc).
Issue: define something like a trigger description?

## Receving Linked Data Notifications ## {#trigger-ldn}

Sending a Linked Data Notification is the primary way to provoke action from the Orchestrator. 
Common senders of notifications are:
- a [=maintainer=] by using the [=Dashboard=], who performed a manual operation on a artefact (eg. creating a new artefact) and wants to trigger consecutive action (eg. announcing that artefact);
- a [=service hub=] or other [=actor=] who has performed an operation related to an artefact (eg. created a comment about that artefact) stored in the maintainer's data pod and is therefore of potential interest to the orchestrator.

To be able to read the notifications from an [=inbox=],
An orchestrator MUST be a compliant [[LDN#consumer]].
It MAY watch zero or more advertise inboxes, as mentioned in [[#init]] and MUST retrieve incoming Linked Data Notifications from all advertised inboxes.
Inboxes MAY be authenticated according to [[LDN#authenticated-inboxes]], which is discussed further in [[#security-considerations]].

The definitions of all possible [[!LDN]] notifications using the [[!ACTIVITYSTREAMS-VOCABULARY]] are listed in the [[spec-notifications]]. 
An orchestrator MUST at least support the following subset:

- [as:Create](https://www.w3.org/ns/activitystreams#Create)
- [as:Announce](https://www.w3.org/ns/activitystreams#Announce)
- [as:Update](https://www.w3.org/ns/activitystreams#Update)
- [as:Delete](https://www.w3.org/ns/activitystreams#Delete)
- [as:Undo](https://www.w3.org/ns/activitystreams#Undo)
- [as:Accept](https://www.w3.org/ns/activitystreams#Accept)
- [as:Reject](https://www.w3.org/ns/activitystreams#Reject)

Issue(8): What notifications do NOT trigger the orchestrator?

When receiving a notification, the orchestrator validates the received notification to all notification-based triggers mentioned in its [=policy=].
Linked Data Notification triggers SHOULD be defined as RDF data shapes, compliant to the [[!SHACL]] specification. 
The shape definitions MAY also conform to the \[SHEX](https://shex.io/) language.


<div class=example>
Example of a Linked Data Notifications trigger using SHACL:
```
{
  "@context": "https://www.example.org/ns/policy",
  "type": "StateTrigger",
  "resource": "https://mypod.org/resources/,
  "state": ["Create", "Update"]
  "summary": "Linked Data Notification Trigger",
}
ex:LDNTriggerShape
  a sh:NodeShape ;
  sh:targetClass as:Create ;    # Applies to all create notifications
  sh:property [                 # _:b1
    sh:path as:actor ;          # only select triggers from organizations
    sh:maxCount 1 ;
    sh:class schema:Organization ;
    sh:nodeKind sh:IRI ;
  ] ;
  sh:property [                 # _:b2
    sh:path as:object ;         # only select triggers about dataset
    sh:maxCount 1 ;
    sh:class schema:Dataset ;
    sh:nodeKind sh:IRI ;
  ] ;
  sh:closed true ;
  sh:ignoredProperties ( rdf:type ) .
```
</div>

## Scheduled trigger ## {#trigger-schedule}

Note: PHOCHSTE: This needs some more work to explain how this could work.

An Orchestrator MAY accept time scheduled triggers for policy actions.
## Observing resource state changes  ## {#trigger-resource}

An orchestrator can also watch LDP resources ([[[LDP#ldpr]]) (e.g, by means of polling) whose state changes issue a trigger.
Hence, an orchestrator MUST accept resource stage changes of [[LDP#ldpr]] as triggers for policy actions.
In case the observed [[[LDP#ldpr]] is also a LDP container ([[LDP#ldpc]]), 
the orchestrator MUST observe state changes for all [[LDP#ldpr]] that are contained by the observed [[LDP#ldpc]].
The Orchestrator MUST request `acl:Read` access all observed [[[LDP#ldpr]] as noted in [[#init]].

At least following state changes MUST issue a trigger:
	- Update of a resource by observing a change in the `Last-Modified` or `ETag` headers.
	- Deletion of a resource by observing a `4XX` status code

Issue: Make resource state changes more concrete: how exactly using HTTP, eg. last modified

In case of an [[LDP#ldpc]], 
the creation or deletion of a container member MUST also issue a trigger.
Thus, the orchestrator SHOULD observe a difference in the set of `?resource` bindings by matching the triple pattern `?container ldp:contains ?resource` on the container's response.


## Scheduled trigger ## {#trigger-schedule}

Finally, some triggers might be configured as recurrent and activate the orchestrator on scheduled intervals.
Therefore, an Orchestrator MUST accept triggers from a time-based job scheduler such as [[cron]]. 

Scheduled trigger can be configured using the crontab; an orchestrator MUST be able to interpret the pattern syntax defined in [[!cron]].
A trigger MUST invoke an action on every matching pattern during the time the trigger is active and the orchestrator is running.

<div class=example>
```
# Issue trigger every weekday morning at 3:15 am

ex:trigger ex:pattern "15 3 * * 1-5"^^ex:crontab
```
</div>

Issue(11): How can you communicate a scheduled trigger from a institutional perspective? for instance, researchers all apply the institutional 

Actions {#actions}
=====================

An <dfn>action</dfn> is a form of interation with other actors or resources in the network.
An Orchestrator performs such [=actions=] on behalf of a network [=actor=].

There are three types of actions that an orchestrator MUST support:
-  sending Linked Data Notifications [[!LDN]] to an [=inbox=] resource, likely belonging to a [=Service Hub=] or [=Data Pod=].
-  manipulating [[!LDP]] resources of a [=Data Pod=].
-  reading arbitrary [[!HTTP11]] resources

## Sending Linked Data notifications

Sending a Linked Data Notification is the primary way to provoke action from other actors in the network. 
Hence, an orchestrator MUST be a compliant [[LDN#sender]].

From the list of possible [[!LDN]] notifications in [[spec-notifications]],
an orchestrator MUST at least be able to send the following subset:

- [as:Create](https://www.w3.org/ns/activitystreams#Create)
- [as:Announce](https://www.w3.org/ns/activitystreams#Announce)
- [as:Update](https://www.w3.org/ns/activitystreams#Update)
- [as:Delete](https://www.w3.org/ns/activitystreams#Delete)
- [as:Undo](https://www.w3.org/ns/activitystreams#Undo)
- [as:Accept](https://www.w3.org/ns/activitystreams#Accept)
- [as:Reject](https://www.w3.org/ns/activitystreams#Reject)

## Reading HTTP resources

A second type of action is reading [[HTTP11]] resources.
Thus, an orchestrator MUST be able to construct a `GET` request.

Issue: does this make sense?

## Manipulating LDP resources

A final action is performing create, read, update and delete operations on a [[LDP#ldpr]] and [[LDP#ldpc]]
Therefore, an Orchestrator MUST be a [[LDP#dfn-ldp-client]] and implement at least the verbs `PUT`, `PATCH` and `DELETE`.

Issue: TODO

- Read: `GET`

## Action descriptions

When a policy rule executed in response to a [=trigger=], it produces zero or more actions.
Each of these actions is captured in a <dfn>action description</dfn>, which uses a simple vocabulary:

: Class
:: `act:Action`
: Subclasses 
:: `act:NotifyAction` | `act:HTTPAction`
: Properties
:: `act:payload` | `act:target` | `act:description`

This vocabulary MUST be interpretable by the orchestrator and MUST result in an executed action.
The specific requirements are discussed per action type below.

<div class='example'>
```
{
  "@context": "https://mellonscholarlycommunication.github.io/vocabulary/act/context",
  "type": "NotifyAction",
  "description": "Notify service hub of artefact creation.",
  "target": "https://servicehub.org/inbox",
  "payload": {
	  "@type": "as:Create",
	  ...
  }
}
```
</div>

<div class='example'>
```
{
  "@context": "https://mellonscholarlycommunication.github.io/context",
  "type": "HttpAction",
  "description": "Notify service hub of artefact creation.",
  "target": "https://servicehub.org/resource",
  "payload": {
	  "@type": "http:Request", 
	  "http:methodName": "POST",
	  ...
  }
}
```
</div>

Deploying an orchestrator {#deploy}
=====================

An Orchestrator MUST be deployable as a <dfn export>local background process</dfn> or as a <dfn export>remote web service</dfn>.
In case of the latter, an actor SHOULD be able to spawn, initialize and trigger the instance over [[!HTTP11]], as defined in [[#deploy]] and [[#triggers]].
The Orchestrator MAY also serve an [=inbox=] for communicating with third-parties using Linked Data Notifications [[LDN]] .

Example of spawning an orchestrator using Linked Data Notifications:
```

POST /inbox HTTP/1.1
Host: example.org
Content-Type: application/ld+json;profile="https://www.w3.org/ns/activitystreams"
Content-Language: en

{
  "@context": "https://www.w3.org/ns/activitystreams",
  "summary": "Spawn orchestrator",
  "type": "Create",
  "actor": "http://kb.nl#me",
  "object": "http://example.org/orchestrator/1"
}
```

If deployed as a [=local background process=], an (custom) API MUST be present that is able perform these actions.


Security considerations {#security-considerations}
==================================================

## Authenticated Inboxes
In case the Orchestrator supports [triggers from incoming Linked Data Notifications](#trigger-ldn), the Orchestrator SHOULD make use of [authenticated inboxes](https://www.w3.org/TR/ldn/#authenticated-inboxes) as described by the [Linked Data Notifications](https://www.w3.org/TR/ldn/) specification.
Requiring authentication on the pod inbox can prevent unwanted parties from forging notifications to be processed by the Orchestrator.

## Signed notifications
Instead of requiring authentication to post notifications to the pod inbox, the Orchestrator may require notifications to be singed by the sender before accepting notifications.
There was an upcoming panel on signed notifications - TODO



Appendix A: Implementation details {#implementation-details}
============================================================

## Retrieving inbox notifications

## Observing LDP resource state updates

## Time based trigger implementations


<pre class=biblio>
{
	"solid-oidc": {
		"authors": [
			"Aaron Coburn (Inrupt)",
			"elf Pavlik",
			"Dmitri Zagidulin"
		],
		"href": "https://solid.github.io/authentication-panel/solid-oidc/",
		"title": "SOLID-OIDC",
		"status": "Editor’s Draft",
		"publisher": "Solid project",
		"deliveredBy": [
			"https://www.w3.org/community/solid/"
		]
	},
	"solid-protocol": {
		"authors": [
			"Sarven Capadisli",
			"Tim Berners-Lee",
			"Ruben Verborgh",
			"Kjetil Kjernsmo",
			"Justin Bingham",
			"Dmitri Zagidulin"
		],
		"href": "https://solidproject.org/TR/protocol/",
		"title": "The Solid Protocol",
		"status": "Editor’s Draft",
		"publisher": "Solid project",
		"deliveredBy": [
			"https://www.w3.org/community/solid/"
		]
	},
  "spec-overview": {
		"authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
		"href": "http://mellonscholarlycommunication.github.io/spec-overview/",
		"title": "Overview of the ResearcherPod specifications",
		"status": "Editor’s Draft",
		"publisher": "ResearcherPod and ErfgoedPod project"
	},
  "spec-rulelanguage": {
		"authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
		"href": "http://mellonscholarlycommunication.github.io/spec-rulelanguage/",
		"title": "Rule language for decentralized business processes",
		"status": "Editor’s Draft",
		"publisher": "ResearcherPod and ErfgoedPod project"
	},
  "spec-notifications": {
		"authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
		"href": "http://mellonscholarlycommunication.github.io/spec-notifications/",
		"title": "List of notifications",
		"status": "Editor’s Draft",
		"publisher": "ResearcherPod and ErfgoedPod project"
	},
  "cron": {
		"authors": ["The Open Group"
    ],
		"href": "https://pubs.opengroup.org/onlinepubs/9699919799/",
		"title": "crontab - schedule periodic background work",
		"status": "Standard",
		"publisher": "IEEE"
	}
}
</pre>
