<pre class='metadata'>
Title: Implémentation de l'Orchestrator pour un réseau Web décentralisé
Shortname: orchestrator
Level: 1
Status: iso/WD
URL: https://mellonscholarlycommunication.github.io/spec-orchestrator
Editor: Miel Vander Sande, meemoo - [Flemish Institute for Archives](https://meemoo.be), miel.vandersande@meemoo.be
Editor: Patrick Hochstenbach, [IDLab - Ghent University](https://knows.idlab.ugent.be), patrick.hochstenbach@ugent.be
Editor: Ruben Dedecker, [IDLab - Ghent University](https://knows.idlab.ugent.be), ruben.dedecker@ugent.be
Editor: Jeroen Werbrouck, [IDLab - Ghent University](https://knows.idlab.ugent.be), Jeroen.Werbrouck@ugent.be
Abstract: Cette spécification décrit les exigences d'implémentation pour le composant Orchestrator.
Markup Shorthands: markdown yes
</pre>

<style>
table {
  margin: 25px auto;
  border-collapse: collapse;
  border: 1px solid #eee;
  border-bottom: 2px solid #005A9C;
}
table tr:hover {
  background: #f4f4f4;
}
table tr:hover td {
  color: #555;
}
table th, table td {
  color: #999;
  border: 1px solid #eee;
  padding: 12px 12px;
  border-collapse: collapse;
}
table th {
  background: #005A9C;
  color: #fff;
}
table th.last {
  border-right: none;
}
</style>

Ensemble de documents {#set}
=======================

Ce document fait partie des spécifications produites par les projets **ResearcherPod** et **ErfgoedPod** :

1. [Aperçu](/spec-overview/)
2. [Orchestrator](/spec-orchestrator/) (ce document)
3. [Data Pod](/spec-datapod/)
4. [Langage de règles](/spec-rulelanguage/)
5. [Journal des événements du cycle de vie des artefacts](/spec-eventlog/)
6. [Notifications](/spec-notifications/)
7. [Collecteur](/spec-collector/)

Introduction {#intro}
=====================

Dans un réseau décentralisé contenant de nombreux [=Data Pod=]s et [=Service Hub=]s, les données et
les services ne se trouvent pas à un seul endroit, mais sont délibérément distribués. En conséquence de
cette décentralisation, les acteurs du réseau (tels que les chercheurs, les institutions ou les fournisseurs de services),
doivent potentiellement impliquer et communiquer avec plusieurs services pour
exécuter un processus métier ou un flux de travail souhaité. Les flux de travail peuvent être des tâches telles que
l'enregistrement d'ensembles de données, la certification de la recherche, la publication dans un journal,
l'indexation de données dans un moteur de recherche et l'archivage de données. Chacune de ces tâches
peut en principe être exécutée par un composant de service dédié. Pour suivre
les interactions entre les [=Artefact=]s (les données) et les [=Service Hub=]s, des traces de provenance
sous forme de [=Artefact Lifecycle Event Log=]s sont générées et les acteurs sont
informés des nouveaux événements dans le réseau. Pour éviter un travail manuel excessif
par les mainteneurs de [=Data Pod=] et [=Service Hub=], un composant Orchestrator est introduit
dans ce document pour automatiser une partie des interactions requises entre les acteurs et
tous les autres composants du réseau.

Les acteurs du réseau conservent leurs données dans un [=Data Pod=], qui est par conception un composant "passif".
Le [=Data Pod=] peut offrir un accès sécurisé aux données via Linked Data Platform [[!LDP]] aux autres, mais
ne peut pas effectuer d'actions telles qu'invocation de services distants sur le réseau ou lecture et écriture
de contenu réseau. Ces capacités sont déléguées aux applications [=Dashboard=] où les acteurs
peuvent interagir manuellement avec le [=Data Pod=] et le réseau et aux [=Orchestrator=]s qui peuvent travailler de façon automatique pour le compte d'acteurs=.

Au nom de l'acteur, un [=Orchestrator=] répond aux déclencheurs [=Trigger=] en exécutant un certain nombre
d'[=Action=]s dictées par un livre de règles ([=Policy=] machine). Les déclencheurs possibles sont des
notifications entrantes, des changements perçus dans les [=Artefact=]s ou une invocation manuelle par un acteur.
Les actions possibles sont :

- Envoi de notifications à d'autres acteurs ;
- Demande d'accès à des ressources dans un [=Data Pod=] ;
- Lecture de données depuis un [=Data Pod=] ;
- Écriture ou ajout de données à un [=Data Pod=].

L'Orchestrator implémente le modèle d'[=Agent Autonome=] : une instance logicielle intelligente
qui opère au nom d'un acteur mais sans aucune interférence de cet acteur.

En pratique, un Orchestrator est dédié à un seul [=Data Pod=] pour lequel il a accès 
à tous les resources pertinentes, y compris la boîte de réception Linked Data Notification [[!LDN]] [=inbox=]
et le [=Artefact Lifecycle Event Log=].

Son autonomie est fournie par la [=Politique=], qui dicte les règles métier de manière déclarative 
en utilisant un [=langage de politique=].

Le reste de ce document spécifie les exigences pour la mise en œuvre d'un composant [=Orchestrator=].

# Conventions du document

Dans ce document, les préfixes des espaces de noms suivants sont utilisés :

<table>
  <thead>
    <tr>
      <th>Préfixe
      <th>Espace de noms
  <tbody>
    <tr>
      <td>acl
      <td>http://www.w3.org/ns/auth/acl#
    <tr>
      <td>as
      <td>https://www.w3.org/ns/activitystreams#
    <tr>
      <td>ex
      <td>https://www.example.org/
    <tr>
      <td>fno
      <td>https://w3id.org/function/ontology#
    <tr>
      <td>foaf
      <td>http://xmlns.com/foaf/0.1/
    <tr>
      <td>ldp
      <td>http://www.w3.org/ns/ldp#
    <tr>
      <td>pol
      <td>https://www.example.org/ns/policy#
    <tr>
      <td>solid
      <td>http://www.w3.org/ns/solid/terms#
 
</table>

Vue panoramique (High-level overview) {#high-level}
=====================

Une instance d'<dfn export>Orchestrator</dfn> est un [=Agent Autonome=] dédié à un seul [=Data Pod=], [=Service Hub=], ou tout autre acteur hébergeant les ressources [=Artefact Lifecycle Event Log=] et [=Inbox=].
Il interprète et exécute les règles métier décrites dans un ou plusieurs documents [=Policy=].
L'Orchestrator surveille l'[=Inbox=] pour d'éventuels déclencheurs, tout en enregistrant les actions qu'il
effectue dans l'[=Artefact  Lifecycle Event Log=].

## Perspectives

### Data Pod

<pre class='include'>
path: images/high-level.svg
</pre>

Du point de vue d'un [=Data Pod=], un [=Mainteneur=] opère le [=Data Pod=] avec l'aide
d'une ou plusieurs applications [=Dashboard=]. Un [=Dashboard=] Scholarly a la capacité de
présenter l'[=Inbox=] et l'[=Artefact  Lifecycle Event Log=] de manière conviviale pour le
[=Mainteneur=].

Lorsqu'un [=Mainteneur=] souhaite envoyer une notification au réseau, ce message est d'abord
envoyé à l'[=Orchestrator=]. Avec l'aide des [=Policies=], l'[=Orchestrator=] transmettra
la notification à un [=Data Pod=] ou à un [=Service Hub=] externe et mettra à jour
l'[=Artefact  Lifecycle Event Log=].

L'[=Orchestrator=] surveille l'[=Inbox=] du [=Data Pod=] pour les notifications entrantes.

Sur la base des notifications entrantes, l'[=Orchestrator=] exécute les règles [=Policies=] qui sont 
contenues dans un ou plusieurs documents [=Policy=].

Les notifications sont un type de [=Trigger=] qui déclenche l'exécution de l'[=Orchestrator=] 
et des règles [=Policy=]. Consultez la section **Triggers** pour découvrir d'autres types de [=Tiggers=].

Il existe deux principales sources de Triggers :

- Les notifications sortantes envoyées par le [=Mainteneur=] vers l'[=Inbox=] LDN de l'[=Orchestrator=].
- Les notifications entrantes envoyées du réseau vers l'[=Inbox=] LDN du [=Data Pod=].

Lorsqu'un déclencheur arrive, l'[=Orchestrator=] du [=Data Pod=] consulte les documents [=Policy=] pour zéro
ou plusieurs règles correspondant au déclencheur. Chaque règle correspondante entraînera zéro ou plusieurs [=Actions=].

Les [=Actions=] de base peuvent impliquer la lecture de ressources depuis ou l'envoi de notifications à des [=Service Hubs=] 
ou d'autres [=Data Pods=] (y compris celui auquel il est connecté). En général, un [=Orchestrator=] est libre
de mettre en œuvre tout type d'[=Actions=] localement définie. Ce document fournira l'ensemble minimum d'[=Actions=] 
qui sont partagées et prises en charge pour toutes les implémentations d'[=Orchestrator=] afin de prendre en charge le réseau ResearchPod et ErfgoedPod.
Toutes les actions prises par l'[=Orchestrator=] sont enregistrées dans l'[=Artefact  Lifecycle Event Log=] du [=Data Pod=]. 
Lorsque l'[=Orchestrator=] du [=Data Pod=] nécessite une entrée manuelle du [=Mainteneur=], il peut communiquer 
cette information via l'[=Inbox=] LDN du [=Data Pod=]. Le [=Dashboard=] présente cet événement 
au [=Mainteneur=] de manière exploitable. Ces actions du [=Mainteneur=] pourraient entraîner 
un nouveau [=Trigger=].

### Service Hub

<pre class='include'>
path: images/high-level-servicehub.svg
</pre>

Du point de vue d'un [=Service Hub=], un [=Orchestrator=] de [=Service Hub=] peut travailler au nom de
le [=Service Hub=] pour établir une réponse automatisée aux notifications d'autres
[=acteurs=] et [=orchestrators=] du réseau dans le contexte du service fourni.

Comme effet secondaire possible, il peut également consulter activement d'autres [=acteurs=] afin
de compléter le service.

L'[=Orchestrator=] du [=Service Hub=] répond en livrant une nouvelle notification dans l'[=Inbox=] de l'acteur qui a invoqué le service.
C'est la [=Policy=] qui dicte quelle réponse construire et quelles [=Actions=] consécutives 
(lire des ressources depuis ou envoyer des notifications à des [=Data Pods=] ou d'autres [=Service Hubs=]) 
doivent être effectuées.

L'[=Orchestrator=] du [=Service Hub=] maintient également un [=Artefact Lifecycle Event Log=] du
toutes les actions entreprises au nom du [=Service Hub=].

De cette manière, les [=Orchestrator=] simulent les services fournis au [=Data Pod=] et au [=Service Hub=].
## Modèle d'interaction commun

<img src="images/high-level-comm.svg" width="900">

Une activité commune commence lorsque le [=Mainteneur=] d'un [=Data Pod=] nécessite un service fourni par un [=Service Hub=].
Les deux [=acteurs=] peuvent être considérés comme exploitant un [=Orchestrator=] pour automatiser leur participation dans le réseau.
Par conséquent, un modèle d'interaction commun est le suivant:

1. Le [=mainteneur=] du [=Data Pod=] `A` effectue une action qui affecte ou intéresse d'autres acteurs dans le réseau (par exemple, ajouter un nouvel artefact dans le data pod).
2. Le [=mainteneur=] utilise le [=Dashboard=] pour refléter cette action en envoyant le déclencheur `événement A` à l'[=Inbox=] de l'[=Orchestrator=] `A`.
3. Ce déclencheur `événement A` entraîne l'exécution de [=Orchestrator=] `A` pour prendre des [=actions=] consécutives.
4. [=Orchestrator=] `A` consulte sa `Policy A` pour le déclencheur reçu, qui, par exemple, dicte qu'il doit informer le [=Service Hub=] `B` de l'événement.
5. [=Orchestrator=] `A` envoie une notification à l'`=Inbox B` du [=Service Hub=] `B`.
6. [=Orchestrator=] `B` du [=Service Hub=] `B` surveille `Inbox B` et est déclenché par la nouvelle notification dans `Inbox B` pour prendre des [=actions=] consécutives.
7. [=Orchestrator=] `B` consulte sa `Policy B` pour le déclencheur reçu, qui, par exemple, dicte que l'événement `événement A` doit être ajouté à l'[=Artefact  Lifecycle Event Log=] du [=Service Hub=] `B`.
8. [=Service Hub=] `B` traite le contenu de la notification reçue à l'aide d'un processus interne (par exemple, évaluation manuelle du contenu, ajout de métadonnées, création d'un nouvel artefact dans le référentiel). Comment cela est fait n'est pas spécifié.
9. Lorsque [=Service Hub=] `B` a terminé le processus, il envoie un déclencheur `événement B` à l'[=Orchestrator=] `B` pour notifier le mainteneur du [=Data Pod=] `A`.
10. [=Orchestrator=] `B` consulte sa `Policy B` qui exige non seulement d'envoyer la notification à l'`Inbox A` du [=Data Pod=] `A`, mais aussi d'ajouter `événement B` à l'[=Artefact  Lifecycle Event Log=] du [=Service Hub=] `B`.
11. L'[=Orchestrator=] `A` du [=Data Pod=] `A` surveille `Inbox A` et est déclenché par la nouvelle notification dans `Inbox A` pour prendre des [=actions=] consécutives.
12. [=Orchestrator=] `A` consulte sa `Policy A`, qui dicte que le nouvel événement doit être ajouté à l'[=Artefact  Lifecycle Event Log=] du [=Data Pod=] `A`.
13. Le [=Dashboard=] affiche l'[=Artefact  Lifecycle Event Log=] `A` au [=mainteneur=] du [=Data Pod=] `A` pour montrer que les actions nécessaires ont été prises.

Initialisation du Data Pod  {#init}
====================

Pour fonctionner de manière autonome, un [=Orchestrator=] doit obtenir l'accès à certaines ressources
dans le [=Data Pod=], respectivement dans le [=Service Hub=] (dans le cas où le [=Orchestrator=] travaille
au nom du Service Hub).
Ces ressources sont mises à disposition de manière sécurisée pour le [=Orchestrator=] en utilisant le
[Web Access Control](https://solidproject.org/TR/protocol#web-access-control)
spécification. Les [=Orchestrator=] conformes aux exigences de mise en œuvre côté client [[solid-protocol#solid-app]]
peuvent accéder à ces ressources et les gérer au nom
du mainteneur.

La section suivante utilisera le préfixe `acl:` pour spécifier les paramètres de contrôle d'accès Web.

La configuration minimale que le [=Data Pod=] (ou le [=Service Hub=]) DOIT avoir:

- Une [=Inbox=] LDN avec:
    - Accès `acl:Read` pour le [=Orchestrator=].
    - Accès `acl:Append` pour le [=Orchestrator=] et le réseau.
- Un [=Artefact Lifecycle Event Log=] avec:
    - Accès `acl:Read` pour le [=Orchestrator=] et le réseau.
    - Accès `acl:Append` pour le [=Orchestrator=].

Le mainteneur du [=Data Pod=] (ou du [=Service Hub=]) DEVRAIT avoir:

- Une entrée de profil WebID pour:
    - L'emplacement de la [=Inbox=] LDN
    - L'emplacement de l'[=Artefact  Lifecycle Event Log=]
    - Le WebId du [=Orchestrator=]

Un [=Data Pod=] PEUT avoir:

- Une [=Inbox=] LDN pour le [=Orchestrator=] avec:
    - Accès `acl:Read` pour le [=Orchestrator=].
- Un conteneur LDP avec une ou plusieurs règles de [=Policy=].

Ces dernières exigences sont destinées aux cas d'utilisation où le [=Data Pod=] (ou le [=Service Hub=]) partage
des ressources avec son [=Orchestrator=].

Tous les acteurs du réseau ont un WebId avec un document de profil qui documente les emplacements Web
des ressources qu'ils gèrent.

Un exemple de profil WebId d'un mainteneur de [=Data Pod=] peut être:

<div class="example">
<pre>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt;.
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.
@prefix as: &lt;http://www.w3.org/ns/activitystreams#&gt;.
@prefix ldp: &lt;http://www.w3.org/ns/ldp#&gt;.
@prefix ex: &lt;https://www.example.org/&gt;.

&lt;&gt;
    a foaf:PersonalProfileDocument;
    foaf:maker &lt;https://alice.institution.org/profile/card#me&gt;;
    foaf:primaryTopic &lt;https://alice.institution.org/profile/card#me&gt;.

&lt;https://alice.institution.org/profile/card#me&gt;
    foaf:name "Alice";
    ldp:inbox &lt;https://alice.institution.org/inbox/&gt;;
    as:outbox &lt;https://alice.institution.org/lifecycle_events/&gt;;
    ex:orchestrator &lt;https://my.institution.org/orchestrator/profile/card.ttl#me&gt;;
    ex:policies &lt;https://alice.institution.org/policies/&gt;;
    a foaf:Person.
</pre>
</div>

Le profil WebId du [=Orchestrator=] pour le [=Data Pod=] ci-dessus peut ressembler à:

<div class="example">
<pre>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt;.
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.
@prefix as: &lt;http://www.w3.org/ns/activitystreams#&gt;.
@prefix ldp: &lt;http://www.w3.org/ns/ldp#&gt;.
@prefix ex: &lt;https://www.example.org/&gt;.

&lt;&gt;
    a foaf:PersonalProfileDocument;
    foaf:maker &lt;https://my.institution.org/orchestrator/profile/card.ttl#me&gt;;
    foaf:primaryTopic &lt;https://my.institution.org/orchestrator/profile/card.ttl#me&gt;.

&lt;https://my.institution.org/orchestrator/profile/card.ttl#me&gt;
    foaf:name "Orchestrator d'Alice";
    ldp:inbox &lt;https://alice.institution.org/orchestrator/inbox/&gt;;
    a foaf:Service.
</pre>
</div>

Dans les deux exemples ci-dessus, nous avons spécifié:

- Une [=Inbox=] LDN pour le mainteneur du [=Data Pod=] `Alice` à: `https://alice.institution.org/inbox/`.
- Un [=Artefact Lifecycle Event Log=] pour `Alice` à: `https://alice.institution.org/lifecycle_events/`.
- Un [=Orchestrator=] pour `Alice` défini par: `https://my.institution.org/orchestrator/profile/card.ttl#me`.
- Des politiques que `Alice` maintient à: `https://alice.institution.org/policies/`.

Pour le [=Orchestrator=] de `Alice`, nous avons spécifié:

- Une [=Inbox=] LDN sur le [=Data Pod=] de `Alice` à: `https://alice.institution.org/orchestrator/inbox/`.

Note: Dans un réseau décentralisé, la boîte de réception de l'Orchestrator peut être à n'importe quel emplacement du réseau
et n'a pas besoin de résider dans le Data Pod de Alice.

Pour le [=Service Hub=], un profil WebId similaire peut être créé. L'emplacement décentralisé de toutes
les [=Inbox=]-s, [=Artefact Lifecycle Event Log=]-s, [=Orchestrator=]-s et documents [=Policy=]
peut être découvert en connaissant le WebId de tous les acteurs du réseau.

Un [=Orchestrator=] PEUT exposer une interface d'initialisation pour aider le [=Mainteneur=] du [=Data Pod=]
à configurer les ressources requises, le profil WebId et les paramètres de contrôle d'accès Web.
Rulebook {#rulebook-sec}
=====================

Pour exécuter la logique métier pour la gestion des notifications, l'[=Orchestrator=] utilise
un ou plusieurs documents [=policy=] écrits par les acteurs du réseau.
Ces politiques doivent être rédigées dans un [=langage de politique=] que l'[=Orchestrator=] comprend.
Dans le [langage de règles](/spec-rulelanguage/), des exemples sont fournis sur la manière dont les politiques peuvent être
écrites dans un langage de règles avec des implémentations possibles en utilisant \[SHACL](https://www.w3.org/TR/shacl/),
 \[SPARQL](https://www.w3.org/TR/sparql11-query/) ou \[Notation3](https://w3c.github.io/N3/spec/) .

Chaque politique dicte ce qui devrait se passer lorsqu'un [=trigger=] se produit au nom du mainteneur de
d'un [=Data Pod=] ou [=Service Hub=]. Le [langage de règles](/spec-rulelanguage/) fournit un moyen
neutre en termes d'implémentation pour exprimer des règles de [=policy=] possibles. 

Dans l'exemple ci-dessous, nous envoyons une notification à Bob lorsque Alice crée un nouvel artefact.

<div class="example">
<pre>
<b>rule</b> "Notifier Bob des nouveaux artefacts créés"

<b>when</b>

   ?notification a as:Create .

<b>then</b>

   ?notification as:target &lt;http://bob.institution.org/profile/card#me&gt; .

   [ a fno:Execution ;
     fno:executed ex:sendNotification
        ex:notification ?notification
   ] .
</pre>
</div>

Lorsque Alice fournit ce document [=policy=] à son [=Orchestrator=], chaque fois
que l'[=Orchestrator=] est déclenché par une notification `as:Create`, cette [=policy=]
sera activée et Bob recevra une copie de la notification. 

En pratique, les documents [=policy=] peuvent provenir de nombreuses sources et sont une composition 
de procédures imposées par:

- préférences personnelles (c'est-à-dire définies par le mainteneur);
- préférences de service (c'est-à-dire l'orchestrateur travaille au nom d'un [=Service Hub=]);
- exigences institutionnelles (c'est-à-dire l'employeur du mainteneur et le propriétaire des artefacts);
- règles de domaine (c'est-à-dire le contexte de collaboration plus large dans lequel l'institution est située);
- législation (c'est-à-dire les obligations légales);

## Publication des politiques

Les documents [=policy=] sont publiés en tant que ressources dans un conteneur LDP d'un [=Data Pod=] ou [=Service Hub=].
Ce conteneur peut être sous le contrôle de l'[=Orchestrator=] ou d'un mainteneur de [=Data Pod=]/[=Service Hub=].
Le document de profil WebID du mainteneur DEVRAIT contenir l'emplacement des
politiques qui doivent être mises à disposition de l'orchestrateur.

Dans l'exemple 1 ci-dessus, les documents [=policy=] d'Alice ont été rendus disponibles à l'emplacement 
`https://alice.institution.org/policies/`.

L'[=Orchestrator=] DOIT avoir des permissions `acl:Read` afin d'exécuter la logique métier
spécifiée dans ces documents.

Lorsqu'un [=trigger=] se produit, l'[=Orchestrator=] consultera toutes les [=policies=] dans le 
emplacements fournis et suivra les instructions.

L'[=Orchestrator=] PEUT offrir uniquement un nombre limité de types d'exécution de [=policy=] au mainteneur.

Lorsqu'une [=policy=] ne peut pas être exécutée en raison d'erreurs, l'[=Orchestrator=] DEVRAIT envoyer une notification
au mainteneur à ce sujet.

Triggers {#triggers}
=====================

Un <dfn>trigger</dfn> est un événement auquel un orchestrator peut répondre en prenant des [=actions=].
Un orchestrator DOIT répondre aux quatre types de triggers suivants:

- une nouvelle notification Linked Data entrante [[!LDN]] dans l'[=Inbox=] du [=Data Pod=]
    - Cette boîte de réception doit être appendable par l'ensemble du réseau
- une nouvelle notification Linked Data entrante [[!LDN]] dans l'[=Inbox=] de l'orchestrator 
    - Cette boîte de réception peut être privée du Mainteneur et de l'Orchestrator
- un changement d'état observé pour des ressources [=data pod=] surveillées
- un déclencheur planifié à partir du planificateur d'événements basé sur le temps interne

Un trigger DOIT être identifiable par un [[!URI]], de sorte que les règles écrites dans le [[spec-rulelanguage]] puissent se référer à son occurrence.

Un [=Orchestrator=] DOIT être un consommateur conforme [[!LDN]] [Consumer](https://www.w3.org/TR/ldn/#consumer).
L'[=Orchestrator=] PEUT annoncer plusieurs boîtes de réception.
Dans ce cas, l'[=Orchestrator=] DOIT récupérer les notifications Linked Data entrantes de toutes les boîtes de réception annoncées.
La sécurité de la boîte de réception est discutée dans la section [considérations de sécurité](#security-considerations).

Un [=Orchestrator=] DEVRAIT être capable de différencier entre les notifications Linked Data envoyées par le
[=Maintainer=] du [=Data pod=], un [=Service Hub=] et par l'[=Orchestrator=] lui-même. Cela
devrait éviter d'envoyer l'[=Orchestrator=] dans une boucle répondant à ses propres déclencheurs.

Un [=Orchestrator=] DEVRAIT avoir une certaine validation des données de formulaire des déclencheurs entrants et ne répondre qu'à  
des déclencheurs correspondant à une forme de données RDF. Des technologies telles que \[SHACL](https://www.w3.org/TR/shacl/),
\[https://shex.io/), \[SPARQL](https://www.w3.org/TR/sparql11-query/) CONSTRUCT ou
\[Notation3](https://w3c.github.io/N3/spec/) peuvent être utilisées pour valider les déclencheurs.

Un [=Orchestrator=] PEUT avoir un mécanisme en place pour valider l'origine des déclencheurs. Des technologies
telles que [Linked Data Proofs](https://w3c-ccg.github.io/ld-proofs/) peuvent être utilisées pour signer toutes 
les notifications Linked Data qui sont envoyées sur le réseau, et sont validées par l'[=Orchestrator=].

Un [=Orchestrator=] DEVRAIT être capable de traiter toute notification décrite dans la 
[Liste des notifications](https://mellonscholarlycommunication.github.io/spec-notifications/).

Un [=Orchestrator=] DEVRAIT être capable d'exécuter un ou plusieurs documents [=Policy=] définis par 
le [=Mainteneur=]. Un exemple de documents [=Policy=] et comment ils peuvent être écrits est disponible dans le
[Langage de règles pour les processus métier décentralisés](https://mellonscholarlycommunication.github.io/spec-rulelanguage/).

Exemple d'un déclencheur `Create` utilisant des notifications Linked Data:

<div class="example">

<pre>

POST /orchestrator/inbox HTTP/1.1
Host: alice.institution.org 
Content-Type: application/ld+json;profile="https://www.w3.org/ns/activitystreams"
Content-Language: en
{
    "@context": "https://www.w3.org/ns/activitystreams",
    "id": "urn:uuid:AD02A16E-2F5C-408E-8A4D-D596C6421969",
    "type": "Create",
    "summary": "Alice a créé un artefact",
    "actor": {
      "id": "https://alice.institution.org/profiles/card#me",
      "type": ["Person"],
      "inbox": "https://alice.institution.org/inbox",
      "name": "Alice"   
    },
    "origin": {
      "id": "https://acme.net/shinyapps/DashBoard123",
      "type": "Application",
      "name": "Tableau de bord d'Alice" 
    },
    "object": "http://alice.institution.org/artefacts/1",
    "published": "2014-09-30T12:34:56Z"
}
</pre>

</div>

Exemple d'une [=Policy=] pour transmettre tous les événements `Create` d'Alice à Bob en utilisant 
une règle [=Policy=]:

<div class="example">

<pre>
<b>rule</b> "Transmettre à Bob"

as:   &lt;https://www.w3.org/ns/activitystreams#&gt;
pol:  &lt;https://www.example.org/ns/policy#&gt;
fno:  &lt;https://w3id.org/function/ontology#&gt;
ex:   &lt;https://www.example.org/&gt;
alice:        &lt;https://alice.institution.org/profiles/card#me&gt;
bob:          &lt;https://bob.institution.org/profiles/card#me&gt;
orchestrator: &lt;https://instutition.org/orchestrator/profile/card#me&gt;

<b>when</b>

 ?notification a as:Create  
 ?notification as:actor alice:

<b>then</b>

 ?notifiction as:target bob:

 [ pol:policy  [
      a fno:Execution ;
      fno:executes ex:sendTarget [
        ex:notification ?notification
      ]
   ]
 ]
</pre>

</div>
## Observer les changements d'état des ressources ## {#trigger-resource}

Remarque : PHOCHSTE : Cela nécessite un peu plus de travail pour expliquer comment cela pourrait fonctionner.

Un orchestrator PEUT accepter les changements d'état des ressources de
[Linked Data Platform Resources](https://www.w3.org/TR/ldp/#ldpr) comme déclencheurs d'actions de politique.
Dans ce cas, l'orchestrator DOIT se voir accorder un accès en lecture à toutes les
[Linked Data Platform Resources](https://www.w3.org/TR/ldp/#ldpr) observées.
Dans le cas où une ressource [Linked Data Platform](https://www.w3.org/TR/ldp/#ldpr) observée
est également un [Linked Data Platform Container](https://www.w3.org/TR/ldp/#ldpc), l'orchestrator DEVRAIT
observer les changements d'état pour toutes les [Linked Data Platform Resources](https://www.w3.org/TR/ldp/#ldpr) 
qui sont contenues par le [Linked Data Platform Container](https://www.w3.org/TR/ldp/#ldpc) observé.
Problème : définir quelque chose comme une description de déclencheur ?

## Réception de notifications Linked Data ## {#trigger-ldn}

L'envoi d'une notification Linked Data est la principale façon de provoquer une action de l'orchestrator. 
Les expéditeurs courants de notifications sont :
- un [=maintainer=] utilisant le [=Dashboard=], qui a effectué une opération manuelle sur un artefact (par exemple, la création d'un nouvel artefact) et souhaite déclencher des actions consécutives (par exemple, l'annonce de cet artefact) ;
- un [=service hub=] ou un autre [=acteur=] qui a effectué une opération liée à un artefact (par exemple, la création d'un commentaire sur cet artefact) stocké dans le pod de données du mainteneur et est donc d'un intérêt potentiel pour l'orchestrator.

Pour pouvoir lire les notifications depuis un [=inbox=],
Un orchestrator DOIT être un consommateur conforme [[LDN#consumer]].
Il PEUT observer zéro ou plusieurs boîtes de réception annoncées, comme mentionné dans [[#init]] et DOIT récupérer les notifications Linked Data entrantes de toutes les boîtes de réception annoncées.
Les boîtes de réception PEUVENT être authentifiées conformément à [[LDN#authenticated-inboxes]], ce qui est discuté plus en détail dans [[#security-considerations]].

Les définitions de toutes les notifications possibles [[!LDN]] utilisant le [[!ACTIVITYSTREAMS-VOCABULARY]] sont répertoriées dans la [[spec-notifications]]. 
Un orchestrator DOIT au moins prendre en charge le sous-ensemble suivant :

- [as:Create](https://www.w3.org/ns/activitystreams#Create)
- [as:Announce](https://www.w3.org/ns/activitystreams#Announce)
- [as:Update](https://www.w3.org/ns/activitystreams#Update)
- [as:Delete](https://www.w3.org/ns/activitystreams#Delete)
- [as:Undo](https://www.w3.org/ns/activitystreams#Undo)
- [as:Accept](https://www.w3.org/ns/activitystreams#Accept)
- [as:Reject](https://www.w3.org/ns/activitystreams#Reject)

Issue(8) : Quelles notifications NE déclenchent PAS l'orchestrator ?

Lors de la réception d'une notification, l'orchestrator valide la notification reçue pour
tous les déclencheurs basés sur les notifications mentionnés dans sa [=policy=]. Des technologies telles que
[[!SHACL]] et \[SHEX](https://shex.io/)  peuvent être utilisées pour valider les notifications.

## Déclencheur planifié ## {#trigger-schedule}

Remarque : PHOCHSTE : Cela nécessite un peu plus de travail pour expliquer comment cela pourrait fonctionner.

Un orchestrator PEUT accepter des déclencheurs planifiés pour des actions de politique.
## Observer les changements d'état des ressources  ## {#trigger-resource}

Un orchestrator peut également observer les ressources LDP ([[[LDP#ldpr]]) (par exemple, par le biais du sondage) dont les changements d'état déclenchent un déclencheur.
Par conséquent, un orchestrator DOIT accepter les changements d'état des ressources [[LDP#ldpr]] en tant que déclencheurs d'actions de règles.
Dans le cas où la [[[LDP#ldpr]] observée est également un conteneur LDP ([[LDP#ldpc]]), 
l'orchestrator DOIT observer les changements d'état pour toutes les [[LDP#ldpr]] qui sont contenues par le [[LDP#ldpc]] observé.
L'Orchestrator DOIT demander l'accès `acl:Read` à toutes les [[[LDP#ldpr]] observées, comme indiqué dans [[#init]].

Au moins les changements d'état suivants DOIVENT déclencher un déclencheur :
   - Mise à jour d'une ressource en observant un changement dans les en-têtes `Last-Modified` ou `ETag`.
   - Suppression d'une ressource en observant un code d'état `4XX`

Problème : Rendre les changements d'état des ressources plus concrets : comment exactement en utilisant HTTP, par exemple la dernière modification

En cas de [[LDP#ldpc]], 
la création ou la suppression d'un membre de conteneur DOIT également déclencher un déclencheur.
Ainsi, l'orchestrator DEVRAIT observer une différence dans l'ensemble des liaisons `?resource` en faisant correspondre le motif triple `?container ldp:contains ?resource` sur la réponse du conteneur.


## Déclencheur planifié ## {#trigger-schedule}

Enfin, certains déclencheurs peuvent être configurés comme récurrents et activer l'orchestrator à intervalles réguliers.
Par conséquent, un Orchestrator DOIT accepter des déclencheurs d'un planificateur d'emplois basé sur le temps tel que [[cron]]. 

Les déclencheurs planifiés peuvent être configurés à l'aide du crontab ; un orchestrator DOIT être capable d'interpréter la syntaxe de modèle définie dans [[!cron]].
Un déclencheur DOIT invoquer une action sur chaque motif correspondant pendant la période pendant laquelle le déclencheur est actif et l'orchestrator est en cours d'exécution.

<div class=example>
```
# Issue trigger every weekday morning at 3:15 am
# Déclencher tous les matins de la semaine à 3 h 15
ex:trigger ex:pattern "15 3 * * 1-5"^^ex:crontab
```
</div>

Issue(11) : Comment peut-on communiquer un déclencheur planifié du point de vue institutionnel ? par exemple, les chercheurs appliquent tous l'institution 

Actions {#actions}
=====================

Une <dfn>action</dfn> est une forme d'interaction avec d'autres acteurs ou ressources dans le réseau.
Un Orchestrator effectue de telles [=actions=] au nom d'un [=acteur=] du réseau.

Il existe trois types d'actions qu'un orchestrator DOIT prendre en charge :
-  envoi de notifications Linked Data [[!LDN]] à une ressource [=inbox=], appartenant probablement à un [=Service Hub=] ou un [=Data Pod=].
-  manipulation des ressources [[!LDP]] d'un [=Data Pod=].
-  lecture de ressources arbitraires [[!HTTP11]]

## Envoi de notifications Linked Data

L'envoi d'une notification Linked Data est la principale façon de provoquer une action auprès d'autres acteurs du réseau. 
Par conséquent, un orchestrator DOIT être un expéditeur conforme [[LDN#sender]].

Parmi la liste des notifications possibles [[!LDN]] dans [[spec-notifications]],
un orchestrator DOIT au moins être capable d'envoyer le sous-ensemble suivant :

- [as:Create](https://www.w3.org/ns/activitystreams#Create)
- [as:Update](https://www.w3.org/ns/activitystreams#Update)
- [as:Delete](https://www.w3.org/ns/activitystreams#Delete)
- [as:Announce](https://www.w3.org/ns/activitystreams#Announce)
- [as:Accept](https://www.w3.org/ns/activitystreams#Accept)
- [as:Offer](https://www.w3.org/ns/activitystreams#Offer)
- [as:Reject](https://www.w3.org/ns/activitystreams#Reject)
- [as:Undo](https://www.w3.org/ns/activitystreams#Undo)

## Lecture des ressources HTTP

Un deuxième type d'action est la lecture des ressources [[HTTP11]].
Ainsi, un orchestrator DOIT être capable de construire une requête `GET`.

Problème : est-ce que cela a du sens ?

## Manipulation des ressources LDP

Une action finale consiste à effectuer des opérations de création, lecture, mise à jour et suppression d'un [[LDP#ldpr]] et [[LDP#ldpc]]
Par conséquent, un Orchestrator DOIT être un [[LDP#dfn-ldp-client]] et implémenter au moins les verbes `PUT`, `PATCH` et `DELETE`.

Problème : TODO

- Lecture : `GET`

## Descriptions d'actions

Lorsqu'une règle du règlement exécutée en réponse à un [=trigger=], elle produit zéro ou plusieurs actions.
Chacune de ces actions est capturée dans une <dfn>description d'action</dfn>, qui utilise un vocabulaire simple :

: Classe
:: `act:Action`
: Sous-classes 
:: `act:NotifyAction` | `act:HTTPAction`
: Propriétés
:: `act:payload` | `act:target` | `act:description`

Ce vocabulaire DOIT être interprétable par l'orchestrator et DOIT aboutir à une action exécutée.
Les exigences spécifiques sont discutées par type d'action ci-dessous.

<div class='example'>
```
{
  "@context": "https://mellonscholarlycommunication.github.io/vocabulary/act/context",
  "type": "NotifyAction",
  "description": "Notify service hub of artefact creation.",
  "target": "https://servicehub.org/inbox",
  "payload": {
     "@type": "as:Create",
     ...
  }
}
```
</div>

<div class='example'>
```
{
  "@context": "https://mellonscholarlycommunication.github.io/context",
  "type": "HttpAction",
  "description": "Notify service hub of artefact creation.",
  "target": "https://servicehub.org/resource",
  "payload": {
     "@type": "http:Request", 
     "http:methodName": "POST",
     ...
  }
}
```
</div>


## Déploiement d'un orchestrator {#deploy}
=====================

Un orchestrator DOIT être déployable en tant que <dfn export>processus en arrière-plan local</dfn> ou en tant que <dfn export>service web distant</dfn>.
Dans le cas de ce dernier, un acteur DEVRAIT être en mesure de lancer, d'initialiser et de déclencher l'instance via [[!HTTP11]], comme défini dans [[#deploy]] et [[#triggers]].
L'orchestrator PEUT également servir une [=inbox=] pour communiquer avec des tiers en utilisant des notifications Linked Data [[LDN]].

Exemple de lancement d'un orchestrator à l'aide de notifications Linked Data :

```
POST /inbox HTTP/1.1
Host: example.org
Content-Type: application/ld+json;profile="https://www.w3.org/ns/activitystreams"
Content-Language: fr

{
  "@context": "https://www.w3.org/ns/activitystreams",
  "summary": "Spawn orchestrator",
  "type": "Create",
  "actor": "http://kb.nl#me",
  "object": "http://example.org/orchestrator/1"
}
```

Si déployé en tant que [=processus en arrière-plan local=], une API (personnalisée) DOIT être présente pour effectuer ces actions.

## Considérations de sécurité {#security-considerations}

### Boîtes de réception authentifiées
Si l'Orchestrator prend en charge [les déclencheurs des notifications Linked Data entrantes](#trigger-ldn), l'Orchestrator DEVRAIT utiliser [des boîtes de réception authentifiées](https://www.w3.org/TR/ldn/#authenticated-inboxes) telles que décrites dans la spécification [Linked Data Notifications](https://www.w3.org/TR/ldn/).
Exiger une authentification sur la boîte de réception peut empêcher des parties indésirables de falsifier des notifications à traiter par l'Orchestrator.

### Notifications signées
Au lieu d'exiger une authentification pour poster des notifications dans la boîte de réception, l'Orchestrator peut exiger que les notifications soient signées par l'expéditeur avant de les accepter.
Il y avait un prochain panel sur les notifications signées - TODO

## Annexe A : Détails de mise en œuvre {#implementation-details}
Si déployé en tant que [=processus en arrière-plan local=], une API (personnalisée) DOIT être présente pour effectuer ces actions.

## Considérations de sécurité {#security-considerations}
Si l'Orchestrator prend en charge [les déclencheurs des notifications Linked Data entrantes](#trigger-ldn), l'Orchestrator DEVRAIT utiliser [des boîtes de réception authentifiées](https://www.w3.org/TR/ldn/#authenticated-inboxes) telles que décrites dans la spécification [Linked Data Notifications](https://www.w3.org/TR/ldn/).
Exiger une authentification sur la boîte de réception peut empêcher des parties indésirables de falsifier des notifications à traiter par l'Orchestrator.

## Notifications signées
Au lieu d'exiger une authentification pour poster des notifications dans la boîte de réception, l'Orchestrator peut exiger que les notifications soient signées par l'expéditeur avant de les accepter.
Il y avait un prochain panel sur les notifications signées - TODO

## Annexe A : Détails de mise en œuvre {#implementation-details}

## Récupération des notifications de la boîte de réception

## Observation des mises à jour d'état des ressources LDP

## Implémentations de déclencheurs basés sur le temps

<pre class=biblio>
{
   "solid-oidc": {
      "authors": [
         "Aaron Coburn (Inrupt)",
         "elf Pavlik",
         "Dmitri Zagidulin"
      ],
      "href": "https://solid.github.io/authentication-panel/solid-oidc/",
      "title": "SOLID-OIDC",
      "status": "Draft de l'éditeur",
      "éditeur": "Projet Solid",
      "livréPar": [
         "https://www.w3.org/community/solid/"
      ]
   },
   "solid-protocol": {
      "authors": [
         "Sarven Capadisli",
         "Tim Berners-Lee",
         "Ruben Verborgh",
         "Kjetil Kjernsmo",
         "Justin Bingham",
         "Dmitri Zagidulin"
      ],
      "href": "https://solidproject.org/TR/protocol/",
      "title": "Le protocole Solid",
      "status": "Draft de l'éditeur",
      "éditeur": "Projet Solid",
      "livréPar": [
         "https://www.w3.org/community/solid/"
      ]
   },
  "spec-overview": {
      "authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
      "href": "http://mellonscholarlycommunication.github.io/spec-overview/",
      "title": "Vue d'ensemble des spécifications de ResearcherPod",
      "status": "Draft de l'éditeur",
      "éditeur": "Projet ResearcherPod et ErfgoedPod"
   },
  "spec-rulelanguage": {
      "authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
      "href": "http://mellonscholarlycommunication.github.io/spec-rulelanguage/",
      "title": "Langage de règles pour les processus métier décentralisés",
      "status": "Draft de l'éditeur",
      "éditeur": "Projet ResearcherPod et ErfgoedPod"
   },
  "spec-notifications": {
      "authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
      "href": "http://mellonscholarlycommunication.github.io/spec-notifications/",
      "title": "Liste des notifications",
      "status": "Draft de l'éditeur",
      "éditeur": "Projet ResearcherPod et ErfgoedPod"
   },
  "cron": {
      "authors": ["The Open Group"
    ],
      "href": "https://pubs.opengroup.org/onlinepubs/9699919799/",
      "title": "crontab - planification du travail périodique en arrière-plan",
      "status": "Standard",
      "éditeur": "IEEE"
   }
}
</pre>

# Remerciements

Nous remercions Herbert Van de Sompel, [DANS + Université de Gand](https://dans.knaw.nl/nl/), hvdsomp@gmail.com
pour sa précieuse contribution à ce projet.
